# Original requirements

En la base de datos de comercio electrónico de la compañía disponemos de la tabla PRICES que refleja el precio final (pvp) y la tarifa que aplica a un producto de una cadena entre unas fechas determinadas. A continuación se muestra un ejemplo de la tabla con los campos relevantes:

## Prices table:
| **BRAND_ID** | **START_DATE**      | **END_DATE**        | **PRICE_LIST** | **PRODUCT_ID** | **PRIORITY** | **PRICE** | **CURR** |
|--------------|---------------------|---------------------|----------------|----------------|--------------|-----------|----------|
| 1            | 2020-06-14 00.00.00 | 2020-12-31 23.59.59 | 1              | 35455          | 0            | 35.50     | EUR      |
| 1            | 2020-06-14 15.00.00 | 2020-06-14 8.30.00  | 2              | 35455          | 1            | 25.45     | EUR      |
| 1            | 2020-06-15 00.00.00 | 2020-06-15 11.00.00 | 3              | 35455          | 1            | 30.50     | EUR      |
| 1            | 2020-06-15 16.00.00 | 2020-12-31 23.59.59 | 4              | 35455          | 1            | 38.95     | EUR      |

### Campos:

- **BRAND_ID:** foreign key de la cadena del grupo (1 = ZARA).
- **START_DATE , END_DATE:** rango de fechas en el que aplica el precio tarifa indicado.
- **PRICE_LIST:** Identificador de la tarifa de precios aplicable.
- **PRODUCT_ID:** Identificador código de producto.
- **PRIORITY:** Desambiguador de aplicación de precios. Si dos tarifas coinciden en un rago de fechas se aplica la de mayor prioridad (mayor valor numérico).
- **PRICE:** precio final de venta.
- **CURR:** iso de la moneda.

### Se pide:

- Construir una aplicación/servicio en SpringBoot que provea una end point rest de consulta tal que:

- Acepte como parámetros de entrada: fecha de aplicación, identificador de producto, identificador de cadena.
- Devuelva como datos de salida: identificador de producto, identificador de cadena, tarifa a aplicar, fechas de aplicación y precio final a aplicar.
- Se debe utilizar una base de datos en memoria (tipo h2) e inicializar con los datos del ejemplo, (se pueden cambiar el nombre de los campos y añadir otros nuevos si se quiere, elegir el tipo de dato que se considere adecuado para los mismos).
- Desarrollar unos test al endpoint rest que  validen las siguientes peticiones al servicio con los datos del ejemplo:

- `Test 1: petición a las 10:00 del día 14 del producto 35455   para la brand 1 (ZARA)`
- `Test 2: petición a las 16:00 del día 14 del producto 35455   para la brand 1 (ZARA)`
- `Test 3: petición a las 21:00 del día 14 del producto 35455   para la brand 1 (ZARA)`
- `Test 4: petición a las 10:00 del día 15 del producto 35455   para la brand 1 (ZARA)`
- `Test 5: petición a las 21:00 del día 16 del producto 35455   para la brand 1 (ZARA)`

# Required Software
- **Spring Boot Web App** -> [JDK 8 or higher](https://www.azul.com/downloads/zulu/) and [Maven](https://maven.apache.org/download.cgi?Preferred=ftp://ftp.osuosl.org/pub/apache/)

# How to start the application (Execute in order)
- **Maven install:** Do a Maven install `mvn install`
- **Web App:** To start the embedded server from the command line use `mvn spring-boot:run`, or just run it from your IDE (run or debug InditexMain class).
- **API Endpoints:** Open a browser and go to `localhost:8080/api`, from there discover all the endpoints.
- **Swagger Documentation:** available at  `localhost:8080/swagger-ui.html`
- **InditexMainTest:** contains the asked tests

# Project Features
- **Architecture:** Hexagonal architecture with DDD (Domain Driven Development) for a rich domain model
- **Domain decoupling** main domain completly decoupled from infraestructure layer
- **HATEOAS endpoints** (Hypermedia as the engine of the application state), all the endpoints are easily traversable
- **HazelCast:** Distributed in memory datagrid to cache database calls (open `hazelcast.yml` to configure its parameters)
- **HazelCast Repositories:** to store runtime data (Entity sequence generation done in batches to reduce database calls)
- **JPA Persistence layer** with custom entity graphs, to retrieve full entities with no n+1 query issues
- **Concurrency Control** with optimistic locking for Product aggregates
- **Resilience** retry pattern in case of database locks
- **Swagger Documentation** API documentation automatically generated by swagger
- **Custom Errorhandling for API endpoints**
- **Lombok:** Framework to reduce boilerplate code for any Java Class.
- **Spring DevTools:** Spring DevTools are enabled, it provides many things to speed up development. e.g. It restart your server automatically after java changes are detected like JRebel does.
- **H2 Database** -> Embedded database for local developments. H2 console is available by default on `http://localhost:8080/h2-console`

# Spring Boot - Profiles
- **application.properties**(default)** default properties used by the application
- **application-H2.properties:** properties used by the persistance layer tests, hazelcast is disabled, data from: `Test.sql`.
- **application-H2Hazel.properties:** properties used only by the hazelcast tests, database is enabled with data from: `Test.sql`.

# Testing
- **Spring Unit tests** -> Are executed with the usual maven lifecycle.